# Texture 
Images that will cover our geometries surface.
Famous texture by [Joao Paulo](https://3dtextures.me/2019/04/16/door-wood-001/):
1. Color (or albedo) - take pixels of texture & applied to geometry
2. Alpha - grayscale image where white visible, black wont
3. Height - grayscale image
    - V move vertices
    - PURPOSE: create some relief
    - to see? add subdivision
4. Normal - add small details
    - X move vertices
    - V lure the light into thinking that face is oriented differently
    - PERF: great, no need to subdivide geo
5. Ambient occlusion - grayscale img
    - fake shadow in the surface's crevices
    - not physically accurate
    - PURPOSE: create contrast
6. Metalness - grayscale image
    - specify which is metallic (white)
    - specify which is non-metallic (black)
    - PURPOSE: create reflection
7. Roughness: grayscale img that come with metalness
    - specify which is rough (white)
    - which is smooth (black)
    - PURPOSE: dissipate the light
    - e.g: rugged carpet no light reflection, water's surface so smooth and we can see the light reflecting on it, wood is uniform due to a clear coat on it
8. PBR - Physically Based Rendering
    - regroup many tech for realistic results
    - standard for realis
    - [source1](https://marmoset.co/posts/basic-theory-of-physically-based-rendering/), [source2](https://marmoset.co/posts/physically-based-rendering-and-you-can-too/)

## Load a Textures
### 0. Getting the image URL using JS
1. [ALT] put it on static folder
2. Use native JS
Image need to be convert to texture to be used, needsUpdate told texture to rerender
```js
  /**
   * Textures
  */
  const image = new Image()
  const texture = new THREE.Texture(image)

  image.onload = () => {
    texture.needsUpdate = true
  }
  image.src = '/textures/door/color.jpg'
```

Apply it to material.
Because WebGL needs a specific format that can be accessed by GPU


```js
const material = new THREE.MeshBasicMaterial({ map: texture })
```
### 2. Use TextureLoader
More straightforward than native js
```js
// 1 textureLoader is multiple use
const textureLoader = new THREE.TextureLoader()
const texture = textureLoader.load(
  'textures/door/color.jpg',
  load // aka success,
  onProgress,
  onError
)
```
### 3. Use LoadingManager
To track loading, error, start, progress cleaner
```js
const loadingManager = new THREE.LoadingManager()
const textureLoader = new THREE.TextureLoader(loadingManager)
const colorTexture = textureLoader.load('textures/door/color.jpg')
const alphaTexture = textureLoader.load('textures/door/alpha.jpg')
const heightTexture = textureLoader.load('textures/door/height.jpg')
const metalnessTexture = textureLoader.load('textures/door/metalness.jpg')
const normalTexture = textureLoader.load('textures/door/normal.jpg')
const roughnessTexture = textureLoader.load('textures/door/roughness.jpg')
const ambientOcclusionTexture = textureLoader.load('textures/door/ambientOcclusion.jpg')

loadingManager.onStart = () => {}
loadingManager.onLoad = () => {}
loadingManager.onProgress = () => {}
loadingManager.onError = () => {}
```
### 4. UV unwrapping
When we are using another geometry, image can be stretched etc. 
- resemble unwrapping an origami wrap to make it flat
- each vertex will have 2D coordinate on a flat plane (usually a square)
- uv coordinates generated by Three.js
- bruno prefer using blender to unwrapped

### 5. Transforming the texture
- repeat
    - vector2 with x y properties
      - default not repeat, last pixel get stretched
    - can be replaced w/ `THREE.RepeatWrapping` on `wrapS` and `wrapT`
    ```js
    colorTexture.repeat.x = 2
    colorTexture.repeat.y = 3
    colorTexture.wrapS = THREE.RepeatWrapping // x
    colorTexture.wrapT = THREE.RepeatWrapping // y

    // mirrored
    colorTexture.wrapT = THREE.MirroredRepeatWrapping
    ```
- offset
    ```js
    colorTexture.offset.x = 0.2
    ```
- rotation
    ```js
    colorTexture.rotation = Math.PI / 4 // 1/8 rotation
    // we want the rotation starts on center instead of bottom left
    colorTexture.center.x = 0.5
    colorTexture.center.y = 0.5
    ```
## Filtering and Mipmapping
- minification filter
- magnification filter
## Texture format & optimisation
- size
- data

## Extra: Where to find the textures
- [poliiigon.com](http://poliigon.com/)
- [3dtextures.me](https://3dtextures.me/)
- [arroway-textures.ch](https://www.arroway-textures.ch/)
